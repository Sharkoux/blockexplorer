{"version":3,"file":"static/js/243.51b17b8c.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/alchemy-sdk/src/internal/request-batcher.ts","../node_modules/alchemy-sdk/src/api/alchemy-provider.ts","../node_modules/bech32/index.js"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\" ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [ \"ropsten\" ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"networks/5.7.1\";\n","export const version = \"providers/5.7.2\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: Formatter.allowNull(address),\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\nconst MAX_CCIP_REDIRECTS = 10;\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    _lastBlockNumber: number\n    _inflight: boolean;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = arrayify(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>) {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return hexConcat(result);\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _supportsEip2544: null | Promise<boolean>;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    supportsWildcard(): Promise<boolean> {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return false; }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n\n        return this._supportsEip2544;\n    }\n\n    async _fetch(selector: string, parameters?: string): Promise<null | string> {\n\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            ccipReadEnabled: true,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        // Wildcard support; use EIP-2544 to resolve the request\n        let parseBytes = false;\n        if (await this.supportsWildcard()) {\n            parseBytes = true;\n\n            // selector(\"resolve(bytes,bytes)\")\n            tx.data = hexConcat([ \"0x9061b923\", encodeBytes([ dnsEncode(this.name), tx.data ]) ]);\n        }\n\n        try {\n            let result = await this.provider.call(tx);\n            if ((arrayify(result).length % 32) === 4) {\n                logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                    transaction: tx, data: result\n                });\n            }\n            if (parseBytes) { result = _parseBytes(result, 0); }\n            return result;\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        const result = await this._fetch(selector, parameters);\n        if (result != null) { return _parseBytes(result, 0); }\n        return null;\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const result = await this._fetch(\"0x3b3b57de\");\n\n                // No address\n                if (result === \"0x\" || result === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(result);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx), 0);\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // IPNS (CID: 1, Type: libp2p-key)\n        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipns) {\n            const length = parseInt(ipns[3], 16);\n            if (ipns[4].length === length * 2) {\n                return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n        if (skynet) {\n            if (skynet[1].length === (34 * 2)) {\n                // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                const urlSafe: Record<string, string> = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                return \"sia:/\\/\" + hash;\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n    _maxFilterBlockRange: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n    disableCcipRead: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.disableCcipRead = false;\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    async ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                value.status = response.statusCode;\n                return value;\n            });\n\n            if (result.data) { return result.data; }\n\n            const errorMessage = (result.message || \"unknown error\");\n\n            // 4xx indicates the result is not present; stop\n            if (result.status >= 400 && result.status < 500) {\n                return logger.throwError(`response not found during CCIP fetch: ${ errorMessage }`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n            }\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        return logger.throwError(`error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, Logger.errors.SERVER_ERROR, {\n            urls, errorMessages\n        });\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    // We only allow a single getLogs to be in-flight at a time\n                    if (!event._inflight) {\n                        event._inflight = true;\n\n                        // This is the first filter for this event, so we want to\n                        // restrict events to events that happened no earlier than now\n                        if (event._lastBlockNumber === -2) {\n                            event._lastBlockNumber = blockNumber - 1;\n                        }\n\n                        // Filter from the last *known* event; due to load-balancing\n                        // and some nodes returning updated block numbers before\n                        // indexing events, a logs result with 0 entries cannot be\n                        // trusted and we must retry a range which includes it again\n                        const filter = event.filter;\n                        filter.fromBlock = event._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n\n                        // Prevent fitler ranges from growing too wild, since it is quite\n                        // likely there just haven't been any events to move the lastBlockNumber.\n                        const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                        if (minFromBlock > filter.fromBlock) { filter.fromBlock = minFromBlock; }\n\n                        if (filter.fromBlock < 0) { filter.fromBlock = 0; }\n\n                        const runner = this.getLogs(filter).then((logs) => {\n                            // Allow the next getLogs\n                            event._inflight = false;\n\n                            if (logs.length === 0) { return; }\n\n                            logs.forEach((log: Log) => {\n                                // Only when we get an event for a given block number\n                                // can we trust the events are indexed\n                                if (log.blockNumber > event._lastBlockNumber) {\n                                    event._lastBlockNumber = log.blockNumber;\n                                }\n\n                                // Make sure we stall requests to fetch blocks and txs\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\n                                this.emit(filter, log);\n                            });\n                        }).catch((error: Error) => {\n                            this.emit(\"error\", error);\n\n                            // Allow another getLogs (the range was not updated)\n                            event._inflight = false;\n                        });\n                        runners.push(runner);\n                    }\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string> {\n        if (attempt >= MAX_CCIP_REDIRECTS) {\n            logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                redirects: attempt, transaction\n            });\n        }\n\n        const txSender = transaction.to;\n\n        const result = await this.perform(\"call\", { transaction, blockTag });\n\n        // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n        if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n            try {\n                const data = hexDataSlice(result, 4);\n\n                // Check the sender of the OffchainLookup matches the transaction\n                const sender = hexDataSlice(data, 0, 32);\n                if (!BigNumber.from(sender).eq(txSender)) {\n                    logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                // Read the URLs from the response\n                const urls: Array<string> = [];\n                const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                const urlsData = hexDataSlice(data, urlsOffset + 32);\n                for (let u = 0; u < urlsLength; u++) {\n                    const url = _parseString(urlsData, u * 32);\n                    if (url == null) {\n                        logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    urls.push(url);\n                }\n\n                // Get the CCIP calldata to forward\n                const calldata = _parseBytes(data, 64);\n\n                // Get the callbackSelector (bytes4)\n                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                    logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n                const callbackSelector = hexDataSlice(data, 96, 100);\n\n                // Get the extra data to send back to the contract as context\n                const extraData = _parseBytes(data, 128);\n\n                const ccipResult = await this.ccipReadFetch(<Transaction>transaction, calldata, urls);\n                if (ccipResult == null) {\n                    logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                const tx = {\n                    to: txSender,\n                    data: hexConcat([ callbackSelector, encodeBytes([ ccipResult, extraData ]) ])\n                };\n\n                return this._call(tx, blockTag, attempt + 1);\n\n            } catch (error) {\n                if (error.code === Logger.errors.SERVER_ERROR) { throw error; }\n            }\n        }\n\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params: { transaction, blockTag }, result, error\n            });\n        }\n\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const resolved = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag),\n            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n        });\n        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0: -1);\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await this._getResolver(currentName, \"getResolver\");\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new Resolver(this, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n\n    }\n\n    async _getResolver(name: string, operation?: string): Promise<string> {\n        if (operation == null) { operation = \"ENS\"; }\n\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation, network: network.name }\n            );\n        }\n\n        try {\n            // keccak256(\"resolver(bytes32)\")\n            const addrData = await this.call({\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            });\n            return this.formatter.callAddress(addrData);\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n        }\n\n        return null;\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resolver\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddr = await this._getResolver(node, \"lookupAddress\");\n        if (resolverAddr == null) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        const name = _parseString(await this.call({\n            to: resolverAddr,\n            data: (\"0x691f3431\" + namehash(node).substring(2))\n        }), 0);\n\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(node, \"getAvatar\");\n            if (!resolverAddress) { return null; }\n\n            // Try resolving the avatar against the addr.reverse resolver\n            resolver = new Resolver(this, resolverAddress, node);\n            try {\n                const avatar = await resolver.getAvatar();\n                if (avatar) { return avatar.url; }\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n            }\n\n            // Try getting the name and performing forward lookup; allowing wildcards\n            try {\n                // keccak(\"name(bytes32)\")\n                const name = _parseString(await this.call({\n                    to: resolverAddress,\n                    data: (\"0x691f3431\" + namehash(node).substring(2))\n                }), 0);\n                resolver = await this.getResolver(name);\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n                return null;\n            }\n\n        } else {\n            // ENS name; forward lookup with wildcard\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction spelunk(value: any, requireData: boolean): null | { message: string, data: null | string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data: null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction checkError(method: string, error: any, params: any): any {\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) { return result.data; }\n\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) { result = spelunk(error, false); }\n\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n\n    // @TODO: Should we spelunk for message too?\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n        try {\n            return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"signMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        try {\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_legacySignMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        try {\n            return await this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_signTypedData\",\n                    from: address,\n                    messageData: { domain: populated.domain, types, value: populated.value }\n                });\n            }\n            throw error;\n        }\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue(BigNumber.from((<any>transaction)[key]));\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    if (options.fetchOptions != null) {\n        const opts = options.fetchOptions;\n        if (opts.mode) { request.mode = <RequestMode>(opts.mode); }\n        if (opts.cache) { request.cache = <RequestCache>(opts.cache); }\n        if (opts.credentials) { request.credentials = <RequestCredentials>(opts.credentials); }\n        if (opts.redirect) { request.redirect = <RequestRedirect>(opts.redirect); }\n        if (opts.referrer) { request.referrer = opts.referrer; }\n    }\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    fetchOptions?: Record<string, string>;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\")},\n                body: (dataMatch[2] ? base64Decode(dataMatch[3]): unpercent(dataMatch[3]))\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"web/5.7.1\";\n","import { JsonRpcRequest, JsonRpcResponse } from './internal-types';\n\n/** Maximum size of a batch on the rpc provider. */\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n\n/** Timeout interval before the pending batch is sent. */\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n\n/**\n * Internal class to enqueue requests and automatically send/process batches.\n *\n * The underlying batching mechanism is loosely based on ethers.js's\n * `JsonRpcBatchProvider`.\n *\n * @internal\n */\nexport class RequestBatcher {\n  /** Timeout timer that periodically sends the pending batch. */\n  private pendingBatchTimer: NodeJS.Timer | undefined;\n\n  /**\n   * Array of enqueued requests along with the constructed promise handlers for\n   * each request.\n   */\n  private pendingBatch: Array<BatchRequest> = [];\n\n  constructor(\n    private readonly sendBatchFn: SendBatchFn,\n    private readonly maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE\n  ) {}\n\n  /**\n   * Enqueues the provided request. The batch is immediately sent if the maximum\n   * batch size is reached. Otherwise, the request is enqueued onto a batch that\n   * is sent after 10ms.\n   *\n   * Returns a promise that resolves with the result of the request.\n   */\n  async enqueueRequest(request: JsonRpcRequest): Promise<any> {\n    const inflightRequest: BatchRequest = {\n      request,\n      resolve: undefined,\n      reject: undefined\n    };\n\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n\n    this.pendingBatch.push(inflightRequest);\n\n    if (this.pendingBatch.length === this.maxBatchSize) {\n      // Send batch immediately if we are at the maximum batch size.\n      void this.sendBatchRequest();\n    } else if (!this.pendingBatchTimer) {\n      // Schedule batch for next event loop + short duration\n      this.pendingBatchTimer = setTimeout(\n        () => this.sendBatchRequest(),\n        DEFAULT_REQUEST_BATCH_DELAY_MS\n      );\n    }\n\n    return promise;\n  }\n\n  /**\n   * Sends the currently queued batches and resets the batch and timer. Processes\n   * the batched response results back to the original promises.\n   */\n  private async sendBatchRequest(): Promise<void> {\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this.pendingBatch;\n    this.pendingBatch = [];\n    if (this.pendingBatchTimer) {\n      clearTimeout(this.pendingBatchTimer);\n      this.pendingBatchTimer = undefined;\n    }\n\n    // Get the request as an array of requests\n    const request = batch.map(inflight => inflight.request);\n\n    return this.sendBatchFn(request).then(\n      result => {\n        // For each result, feed it to the correct Promise, depending\n        // on whether it was a success or error\n        batch.forEach((inflightRequest, index) => {\n          const payload = result[index];\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            (error as any).code = payload.error.code;\n            (error as any).data = payload.error.data;\n            inflightRequest.reject!(error);\n          } else {\n            inflightRequest.resolve!(payload.result);\n          }\n        });\n      },\n      error => {\n        batch.forEach(inflightRequest => {\n          inflightRequest.reject!(error);\n        });\n      }\n    );\n  }\n}\n\n/** Function type to match the `fetchJson` function in ethers. */\ntype SendBatchFn = (reqs: JsonRpcRequest[]) => Promise<JsonRpcResponse[]>;\n\n/**\n * Internal interface to represent a request on a batch along with the promises to resolve it.\n */\ninterface BatchRequest {\n  request: JsonRpcRequest;\n  resolve?: (result: any) => void;\n  reject?: (error: Error) => void;\n}\n","import {\n  Network as NetworkFromEthers,\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { deepCopy } from '@ethersproject/properties';\nimport {\n  CommunityResourcable,\n  JsonRpcProvider\n} from '@ethersproject/providers';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\n\nimport { JsonRpcRequest, JsonRpcResponse } from '../internal/internal-types';\nimport { RequestBatcher } from '../internal/request-batcher';\nimport { Network } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { logWarn } from '../util/logger';\nimport { IS_BROWSER } from '../util/util';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n  readonly batchRequests: boolean;\n\n  /**\n   * VISIBLE ONLY FOR TESTING\n   *@internal\n   */\n  readonly batcher: RequestBatcher;\n\n  /** @internal */\n  constructor(config: AlchemyConfig) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n\n    connection.throttleLimit = config.maxRetries;\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n    this.batchRequests = config.batchRequests;\n\n    // TODO: support individual headers when calling batch\n    const batcherConnection = {\n      ...this.connection,\n      headers: {\n        ...this.connection.headers,\n        'Alchemy-Ethers-Sdk-Method': 'batchSend'\n      }\n    };\n    const sendBatchFn = (\n      requests: JsonRpcRequest[]\n    ): Promise<JsonRpcResponse[]> => {\n      return fetchJson(batcherConnection, JSON.stringify(requests));\n    };\n    this.batcher = new RequestBatcher(sendBatchFn);\n\n    this.modifyFormatter();\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER\n        ? {\n            'Alchemy-Ethers-Sdk-Version': VERSION\n          }\n        : {\n            'Alchemy-Ethers-Sdk-Version': VERSION,\n            'Accept-Encoding': 'gzip'\n          },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method: string, params: Array<any>): Promise<any> {\n    return this._send(method, params, 'send');\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\n   *\n   * This method is copied over directly in order to implement custom headers\n   *\n   * @internal\n   */\n  _send(\n    method: string,\n    params: Array<any>,\n    methodName: string,\n    forceBatch = false\n  ): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n\n    // START MODIFIED CODE\n    const connection = { ...this.connection };\n    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;\n\n    if (this.batchRequests || forceBatch) {\n      return this.batcher.enqueueRequest(request as JsonRpcRequest);\n    }\n    // END MODIFIED CODE\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n\n    const result = fetchJson(\n      this.connection,\n      JSON.stringify(request),\n      getResult\n    ).then(\n      result => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this\n        });\n\n        return result;\n      },\n      error => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this\n        });\n\n        throw error;\n      }\n    );\n\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n\n    return result;\n  }\n\n  /**\n   * Overrides the base `Formatter` class inherited from ethers to support\n   * returning custom fields in Ethers response types.\n   *\n   * For context, ethers has a `Formatter` class that is used to format the\n   * response from a JSON-RPC request. Any fields that are not defined in the\n   * `Formatter` class are removed from the returned response. By modifying the\n   * `Formatter` class in this method, we can add support for fields that are\n   * not defined in ethers.\n   */\n  private modifyFormatter(): void {\n    this.formatter.formats['receiptLog']['removed'] = val => {\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      return undefined;\n    };\n  }\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Original code copied over from ether.js's\n * `@ethersproject/web/src.ts/index.ts`. Used to support\n * {@link AlchemyProvider._send}, which is also copied over.\n */\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n"],"names":["logger","Logger","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","push","error","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","indexOf","name","CloudflareProvider","cloudflare","AnkrProvider","ankr","length","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","throwArgumentError","value","defaultProvider","version","Formatter","_classCallCheck","this","formats","getDefaultFormats","_createClass","key","_this","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","shallowCopy","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","BigNumber","toNumber","toLowerCase","Error","strict","substring","isHexString","result","getAddress","hexDataSlice","getContractAddress","hexValue","hexDataLength","hexZeroPad","format","author","_difficulty","check","_block","gas","isZero","input","networkId","parseInt","replace","parseTransaction","byzantium","_this2","Array","isArray","map","object","checkKey","checkValue","nullValue","replaceValue","array","forEach","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","ForkEvent","isForkEvent","warn","getTime","Date","stall","duration","Promise","resolve","setTimeout","PollableEvents","Event","tag","listener","once","defineReadOnly","_lastBlockNumber","_inflight","get","split","comps","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","Base58","encode","concat","sha256","matcherIpfs","RegExp","matchers","_parseString","start","toUtf8String","_parseBytes","offset","getIpfsLink","link","match","numPad","arrayify","padded","Uint8Array","set","bytesPad","Math","ceil","encodeBytes","datas","byteCount","i","hexConcat","Resolver","resolvedAddress","formatter","_supportsEip2544","call","then","eq","catch","code","errors","CALL_EXCEPTION","selector","parameters","tx","ccipReadEnabled","namehash","parseBytes","_context","next","supportsWildcard","sent","dnsEncode","prev","throwError","abrupt","t0","stop","_callee","_fetch","_context2","_callee2","coinType","hexBytes","coinInfo","String","UNSUPPORTED_OPERATION","operation","bytes","words","bech32","unshift","_context3","callAddress","_fetchBytes","_getAddress","_callee3","linkage","content","_context4","getText","avatar","scheme","t1","_resolvedAddress","owner","addr","tokenId","t2","t3","tokenOwner","t4","t5","balance","toString","t6","t7","metadataUrl","fetchJson","metadata","JSON","stringify","imageUrl","image","t8","_callee4","_context5","ipfs","ipns","swarm","skynet","urlSafe","base64Encode","a","_callee5","keyBytes","toUtf8Bytes","_context6","hexlify","_callee6","defaultFormatter","nextPollId","BaseProvider","_Provider","_inherits","_super","_createSuper","_events","_emitted","disableCcipRead","constructor","getFormatter","_assertThisInitialized","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","_context7","UNKNOWN_ERROR","_callee7","_this3","poll","NETWORK_ERROR","event","calldata","urls","_context8","sender","errorMessages","href","json","errorPassThrough","response","statusCode","errorMessage","message","SERVER_ERROR","m","_callee8","maxAge","_context9","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_ref","_this4","_setFastBlockNumber","_callee9","pollId","runners","_context10","_getInternalBlockNumber","pollingInterval","abs","makeError","previousBlockNumber","eventBlockNumber","_this5","runner","getTransactionReceipt","minFromBlock","getLogs","log","all","_callee10","polling","_context11","_callee11","_context12","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_callee12","_this6","_poller","_this7","setInterval","_bootstrapPoll","clearInterval","_this8","_this9","now","getBlockNumber","timeout","_waitForTransaction","_context13","_callee13","replaceable","_context16","reject","cancelFuncs","done","alreadyDone","minedHandler","_this10","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","_regeneratorRuntime","mark","_callee15","_this11","wrap","_context15","getTransactionCount","_callee14","mined","ti","_receipt","reason","_context14","getTransaction","getBlockWithTransactions","waitForTransaction","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","_callee16","_context17","_callee17","_context18","method","_callee18","addressOrName","_context19","_getBlockTag","params","_callee19","_context20","_callee20","_context21","_callee21","position","_context22","p","_callee22","_this12","expectedHash","returnedHash","wait","confirms","_callee23","_context23","signedTransaction","_context24","t","hexTx","_callee24","values","_context25","_this13","_callee25","_context26","_this14","_callee26","attempt","redirects","txSender","_context27","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipReadFetch","ccipResult","_call","_callee27","_context28","_getTransactionRequest","resolved","_callee28","_context29","_callee29","_context30","resolveName","_callee30","blockHashOrBlockTag","includeTransactions","_context32","_this15","_callee31","_blockNumber","blockWithTxs","_this16","_context31","oncePoll","_callee32","_getBlock","_context34","_this17","_callee33","_context33","_callee34","_context36","_this18","_callee35","_context35","_callee36","_context37","_getFilter","_callee37","_context38","_callee38","_context39","_callee39","currentName","_context40","_getResolver","resolver","_callee40","_context41","addrData","_callee41","_context42","getResolver","_callee42","_context43","node","resolverAddr","_callee43","nameOrAddress","_context44","resolverAddress","getAvatar","_callee44","NOT_IMPLEMENTED","e","pollable","_startEvent","_addEventListener","_this19","_len","arguments","args","_key","stopped","eventTag","apply","_stopEvent","_this20","removeAllListeners","found","_this21","Provider","errorGas","spelunk","requireData","parse","checkError","body","UNPREDICTABLE_GAS_LIMIT","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","_Signer","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","estimateGas","hexlifyTransaction","ACTION_REJECTED","action","sendUncheckedTransaction","messageData","domain","types","_TypedDataEncoder","resolveNames","populated","getPayload","password","Signer","_JsonRpcSigner","_super2","allowedTransactionKeys","_BaseProvider","_super3","networkOrReady","freeze","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","serverError","getSigner","connectUnchecked","request","id","jsonrpc","deepCopy","cache","connection","getFeeData","feeData","prepareRequest","_startPending","_get","_getPrototypeOf","prototype","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","checkProperties","getUrl","headers","skipFetchSetup","mode","credentials","redirect","referrer","fetchOptions","opts","fetch","arrayBuffer","statusMessage","statusText","staller","bodyify","isBytesLike","trim","processFunc","updated","k","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","allow304","allowGzip","user","allowInsecureAuthentication","INVALID_ARGUMENT","argument","authorization","reData","dataMatch","base64Decode","fromCharCode","requestBody","requestMethod","flatHeaders","header","runningTimeout","promise","cancel","runningFetch","location","tryAgain","retryAfter","random","pow","throttleRetry","race","_fetchData","floor","ceiling","interval","retryLimit","onceBlock","RequestBatcher","sendBatchFn","maxBatchSize","pendingBatch","inflightRequest","sendBatchRequest","pendingBatchTimer","batch","inflight","index","_JsonRpcProvider","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","maxRetries","ethersNetwork","EthersNetwork","batchRequests","batcherConnection","assign","batcher","requests","modifyFormatter","logWarn","DEFAULT_ALCHEMY_API_KEY","_send","methodName","forceBatch","enqueueRequest","val","CustomNetworks","DEFAULT_NETWORK","Network","includes","getAlchemyHttpUrl","getAlchemyWsUrl","IS_BROWSER","VERSION","ALPHABET","ALPHABET_MAP","z","x","charAt","TypeError","polymodStep","pre","b","prefixChk","chk","c","charCodeAt","__decode","str","LIMIT","lowered","uppered","toUpperCase","lastIndexOf","wordChars","convert","inBits","outBits","pad","bits","maxV","module","exports","decodeUnsafe","res","decode","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords"],"sourceRoot":""}